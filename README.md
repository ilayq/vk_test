# Setup and usage instructions
### Setup with docker-compose

1. Clone repository
    ```git clone git@github.com:ilayq/vk_test.git```
2. Go to cloned folder
    ```cd vk_test/```
3. Create ```.env``` file for docker-compose
4. Fill ```.env``` 
    ```
    POSTGRES_USER=postgres
    POSTGRES_PASSWORD=hackme
    POSTGRES_DB=database_name
    SECRET_KEY=secret_key_to_encrypt_user_data
    ADMIN_LOGIN=login_to_log_in_as_admin
    ADMIN_PASSWORD=password_to_log_in_as_admin
    ```
5. Run ```docker compose up```
After this server will run on ```0.0.0.0:8000```. If you want to change address, go to ```main.py``` and change
```uvicorn.run('main:app', host='0.0.0.0', port=8000)``` with your host and port.
##### Explanations
```POSTGRES_USER```, ```POSTGRES_PASSWORD``` and ```POSTGRES_DB``` enviroment variables are used to connect to PostgresDB
```ADMIN_LOGIN``` and ```ADMIN_PASSWORD``` are used to login as admin and get access to api calls

### Tests
If you want to run tests before running service, you need running instance of Postgres.
1. Provide all environment varialbles that listed in ```.env``` and additionally ```HOST``` if your Postgres instance is running on remote server. 
You should provide these variables like this: ```HOST=127.0.0.0.1```
2. Install python requirements with ```python3 -m pip install -r requirements.txt```
3. Run ```python3 -m pytest tests/```


### P.S. Комментарии по проекту
##### 1. Архитектура API
По моему мнению было бы лучше сделать 2 эндпоинта ```/user``` и  ```/lock``` и на каждый из них по два обработчика, 
1. ```GET /user``` - получение аккаунтов
2. ```POST /user``` - добавление аккаунта
3. ```POST /lock?user_id={user_id}``` - наложить блокировку на пользователя
4. ```DELETE /lock?user_id={user_id}``` - снять блокировку с пользователя
Такая архитектура больше подходит под стандарты RestAPI, а эндпоинты, предложенные в ТЗ больше подходят под стандарт RPC.
##### 2. Миграции и Enum-типы
Alembic не умеет работать с Enum-типами (или делает это плохо), по этой причине, в ORM моделях я не создавал аттрибуты с типом Enum, хотя он поддерживается в SQLALchemy и Postgres, и в целом, типы Enum я бы отнес к бизнес-логике, а ее лучше оставлять на стороне сервера, а не базы данных. Проблема Alembic в том, что, если откатить миграцию, в которой были созданы Enum-типы, alembic не удаляет их из базы данных, таким образом при запуске ```alembic upgrade ...```, возникнет ошибка, в том, что эти типы уже есть в базе данных. 
##### 3. Авторизация
В ТЗ сказано, что за авторизацию есть дополнительная оценка, но не сказано, куда именно пользователь должен авторизоваться, поэтому я сделал так, что все эндпоинты закрыты, пока пользователь не авторизуется в качестве админа.
##### 4. Шифрование
Опять же, в ТЗ сказано шифровать все пароли от аккаунтов, и изначально я хотел написать классическое решение с хешированием паролей и последующей проверкой хешей, но логика задания подразумевает, что пользователь получает список аккаунтов и может с их помощью где-то авторизоваться, поэтому я сделал симметричное шифрование, чтобы в базе данных хранились пароли в зашифрованном виде, а пользователю отдавались в обычном. Ключ шифрования достается из переменной окружения, и "костыльным" образом приводится в нужному формату. Это небезопасно, но если генерировать ключ при запуске сервера и хранить его в рантайме, невозможно будет дешифровать данные в случае падения сервера.
##### 5. Тесты
Предложенный фреймворк для тестирования, pytest, плохо работает с асинхронными тестами, поэтому в дополнение к нему потребовался плагин pytest-asyncio. Из-за тех же проблем с асинхронностью я не использовал ```@pytest.fixture``` и ```@pytest_asyncio.fixture``` для инициализации базы данных для тестов, в которых она требуется. При использовании фикстур с асинхронными тестами, происходила ситуация, когда один тест кончался раньше, и фикстура пыталась удалить тестовую базу данных, что приводило к ошибкам в остальных тестах. Я не нашел решение этой проблемы, поэтому написал свой контекстный менеджер, создающий отдельную базу данных для каждого теста.
##### 6. Locktime 
Из условий задания, я не совсем понял, зачем хранить время, когда аккаунт был заблокирован. В моем понимании это поле играет роль флага, занят ли аккаунт, поэтому я использовал тип данных timestamp без метки часового пояса, хотя рекомендуется использовать метку времени с часовым поясом.
##### 7. Валидация данных
В ТЗ упоминается валидация входных данных, но ни слова не сказано про то, в каком формате они должны быть, поэтому я не стал делать дополнительную валидацию, кроме той, что автоматически выполняет Pydantic.
### P.S.S Если не хочется разворачивать сервер, можно зайти на http://185.195.25.237:8000/docs, логин: admin, пароль: admin